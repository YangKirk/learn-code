# -*- coding: utf-8 -*-
"""
-------------------------------------------------
   File Name：     leetcode_1877th
   Description :  
   Author :       kirk
   date：          2021/7/22
-------------------------------------------------
   Change Activity:
                   2021/7/22
-------------------------------------------------
"""
"""
一个数对(a,b)的 数对和等于a + b。最大数对和是一个数对数组中最大的数对和。

比方说，如果我们有数对(1,5)，(2,3)和(4,4)，最大数对和为max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8。
给你一个长度为 偶数n的数组nums，请你将 nums中的元素分成 n / 2个数对，使得：

nums中每个元素恰好在 一个数对中，且
最大数对和的值 最小。
请你在最优数对划分的方案下，返回最小的 最大数对。


示例 1：

输入：nums = [3,5,2,3]
输出：7
解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。
最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。
示例 2：

输入：nums = [3,5,4,2,4,6]
输出：8
解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。
最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。


提示：

n == nums.length
2 <= n <= 10^5
n是 偶数。
1 <= nums[i] <= 10^5
"""


# 根据题意，如果要最大数对和最小，就需要最大值和最小值相加，所以就需要排序，并且从两边挨个配对。
# 在配对过程中寻找最大值
class Solution:
    @staticmethod
    def min_pair_sum(nums: list):
        n = len(nums)
        nums.sort()  # 先排序
        res = 0
        for i in range(n // 2):  # 再遍历数组，因为是偶数，不用再次判断
            if res < (nums[i] + nums[n - 1 - i]):  # n-1-i 是右边对应位置的坐标
                res = (nums[i] + nums[n - 1 - i])
        return res


if __name__ == '__main__':
    # num = [3, 5, 2, 3]
    num = [3, 5, 4, 2, 4, 6]
    print(Solution.min_pair_sum(num))
